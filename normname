#!/usr/bin/env bash
#
# Normalize file names.
#
# Helps to keep simple naming conventions for files. For the full set of modifications
# see the function `normalize`.
#

set -o errexit

help_msg="\
usage:
  ${0} FILE...
"

# Return normalized version of ${1}.
#
# * Change uppercase to lowercase.
# * Replace sequences of dashes, whitespaceses and underscores with a single
#   underscore.
# * Remove Czech diacritics.
normalize() {
    local DIACRITICS NO_DIACRITICS
    readonly DIACRITICS='ěščřžýáíéĚŠČŘŽÝÁÍÉ'
    readonly NO_DIACRITICS='escrzyaieESCRZYAIE'
    echo "${1}" \
        | sed "y/${DIACRITICS}/${NO_DIACRITICS}/" \
        | tr '[:upper:]' '[:lower:]' \
        | tr --squeeze-repeats ' -' '_'
}


# Main entry point
main() {
    if [[ ${#} -eq 0 ]]; then
        echo "error: missing files to operate on" >&2
        echo "${help_msg}" >&2
        exit 1
    fi

    local orig_path orig_dir orig_name new_name
    for orig_path in "${@}"; do
        orig_dir=$(dirname "${orig_path}")
        orig_name=$(basename "${orig_path}")
        new_name=$(normalize "${orig_name}")

        if [[ "${new_name}" != "${orig_name}" ]]; then
            local new_path
            if [[ "${orig_dir}" == "." ]]; then
                new_path="${new_name}"
            else
                new_path="${orig_dir}/${new_name}"
            fi
            # TODO: consider adding --no-clobber flag to prevent overwriting an
            # existing file
            mv "${orig_path}" "${new_path}"
            echo "${orig_path} -> ${new_path}"
        fi
    done
}


main "${@}"
